using System.CodeDom.Compiler;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Solaris.SourceGen;

[Generator(LanguageNames.CSharp)]
public class PublicKeyCastDetectorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var syntaxProvider = context.SyntaxProvider.CreateSyntaxProvider(
                (s, _) => s is CastExpressionSyntax
                    or LiteralExpressionSyntax
                    or ImplicitObjectCreationExpressionSyntax
                    or ObjectCreationExpressionSyntax,
                (ctx, _) => GetInterestingNode(ctx)
            ).Where(m => m != null)
            .Collect();

        context.RegisterSourceOutput(syntaxProvider, Build!);
    }

    private static SyntaxNode? GetInterestingNode(GeneratorSyntaxContext context)
    {
        var node = context.Node;

        return node switch
        {
            // For each kind, check if it involves PublicKey
            CastExpressionSyntax castExp when IsCastPublicKey(castExp, context.SemanticModel) => castExp,
            LiteralExpressionSyntax literal when literal.IsKind(SyntaxKind.StringLiteralExpression) &&
                                                 IsCastPublicKey(literal, context.SemanticModel) => literal,
            ObjectCreationExpressionSyntax ctor when IsStringCtorPublicKey(ctor, context.SemanticModel) => ctor,
            ImplicitObjectCreationExpressionSyntax implCtor when IsStringCtorPublicKey(implCtor, context.SemanticModel)
                => implCtor,
            _ => null
        };
    }

    private static bool IsStringCtorPublicKey(ExpressionSyntax expression, SemanticModel model)
    {
        if (model.GetSymbolInfo(expression).Symbol is IMethodSymbol symbol)
            return symbol.OriginalDefinition.ToString() ==
                   "Solaris.Base.Account.PublicKey.PublicKey(string)"; // new PublicKey(string) constructor

        return false;
    }

    private static bool IsCastPublicKey(ExpressionSyntax expression, SemanticModel model)
    {
        if (model.GetSymbolInfo(expression).Symbol is IMethodSymbol symbol)
            return symbol.OriginalDefinition.ToString() ==
                   "Solaris.Base.Account.PublicKey.implicit operator Solaris.Base.Account.PublicKey(string)"; // implicit cast from string to PublicKey

        return false;
    }

    private static void Build(
        SourceProductionContext context,
        ImmutableArray<SyntaxNode> source)
    {
        var pubKeys = GetPublicKeyValues(source).Distinct();

        using var sw = new StringWriter();
        using var writer = new IndentedTextWriter(sw);

        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine("namespace Solaris.Generated");
        writer.WriteLine('{');
        writer.Indent++;
        writer.WriteLine("using System.Collections.Frozen;");
        writer.WriteLine("using Solaris.Base.Account;");
        writer.WriteLine();
        writer.WriteLine("public class PublicKeyCache : ISharedDictionary");
        writer.WriteLine('{');
        writer.Indent++;
        writer.WriteLine(
            $"private static readonly FrozenDictionary<string, PublicKey> Dict = new[] {{ {string.Join(", ", pubKeys.Select(x => $"(\"{x}\", new byte[] {{ {string.Join(", ", Base58.DecodePlain(x))} }})"))} }}.ToFrozenDictionary(x => x.Item1, x => PublicKey.InitializeFromCache(x.Item1, x.Item2));");
        writer.WriteLine("public FrozenDictionary<string, PublicKey> Dictionary => Dict;");
        writer.Indent--;
        writer.WriteLine('}');
        writer.Indent--;
        writer.WriteLine('}');

        context.AddSource("PublicKeyGenerated.g.cs", sw.ToString());
    }

    private static string[] GetPublicKeyValues(ImmutableArray<SyntaxNode> source)
    {
        return source.Select(x => x switch
            {
                CastExpressionSyntax cast => ((LiteralExpressionSyntax)cast.Expression).Token.ValueText,
                LiteralExpressionSyntax implCast => implCast.Token.ValueText,
                ObjectCreationExpressionSyntax ctor => ((LiteralExpressionSyntax)ctor.ArgumentList!.Arguments[0]
                    .Expression).Token.ValueText,
                ImplicitObjectCreationExpressionSyntax ctor => ((LiteralExpressionSyntax)ctor.ArgumentList!.Arguments[0]
                    .Expression).Token.ValueText,
                _ => null
            })
            .Where(x => x != null)
            .ToArray()!;
    }
}